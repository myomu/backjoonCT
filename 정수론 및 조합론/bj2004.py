# 조합 0의 개수
# 메모이제이션 기법으로 풀면 메모리초과가 뜬다.
# 이때 문제가 요구하는 뒷자리 0이 얼마인지 구하는 방식은 다른 방법으로 풀어야한다.
# 뒷자리가 0이 오는 것은 10이 곱해져 있는 것이므로 10의 제곱이 2이면 00이 붙는다.
# 10의 소인수분해인 2와 5로 이루어져 있고 팩토리얼의 경우 결국 2의 승수보다 5의 승수가 더 적기 때문에
# 5의 승수값을 알 수 있으면 0의 개수를 알 수 있다.
# 그리고 팩토리을의 N값을 5로 나눈다면 예를들어 10을 5로 나누면 몫이 2가 되는데 이 2라는 값은 10!에서 5로 나눌 수 있는
# 수가 2개임을 말하기도 한다. 10 9 8 7 6 5 4 3 2 1 에서 5로 나누어지는 것은 10과 5 둘 뿐이다.
# 이 특성을 이용해서 100!을 체크하면 100/5 = 20, 100/25 = 4, 100/125 = 0... 20+4=24. 24개의 0으로 이루어짐을 알 수 있다.
# 여기에 이항 계수의 정의를 사용하면 nCr = n! / (n-r)! * r! 이므로 n!, (n-r)!, r! 에서 각자 구하여 계산해주면된다.
# 틀림 주의!!
# 조합에서는 5의 개수만 신경 쓸 수 없다. ex)125 1 의 경우 5의 값이 2의 값 보다 많아지므로 2의 승수를 구하는 계산도 필요하다!

N, K = map(int, input().split())

def cal(n, r):
    cnt = 0
    v = r
    while n >= v:
        cnt += (n//v)
        v *= r
    return cnt

five = cal(N, 5)-cal(N-K, 5)-cal(K, 5)
two = cal(N, 2)-cal(N-K, 2)-cal(K, 2)
print(min(five, two))
